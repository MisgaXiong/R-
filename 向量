#向量是R语言最基本的数据类型。重点：
#1.循环补齐：在一定情况下自动延长向量；
#2.提取向量子集；
#3.向量化：对向量的每一个元素应用函数。
x<-c(1,2,3,4,5) #把向量赋值给x，c是连接函数。
length(x) #获取向量长度
[1] 5
x[-1:-2] #删除x前两个元素
[1] 3 4 5
x<-x[-1:-2] #删除x前两个元素并保存
x
[1] 3 4 5
x<-c(x[c(1,3)],2,0,1,x[2]) #把x的第一个和第三个元素提取作为新x的第一和第二个元素，并将x的第二的元素提取作为新x的最后一个元素，并在x的第二和最后一个元素之间加入三个新元素，并保存至新x
x
[1] 3 5 2 0 1 4
 b<-seq(from=1,to=100,by=2) #seq函数是生成等差数列函数，并赋给b向量
 b
 [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55
[29] 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 #前面的[1]是计数，代表第一个，57前面的[29]代表57是第29个数
#当向量中元素非常多，而我们又想知道里面奇数有多少个的时候，我们可以利用简单的for循环完成
#例如，我们产生一个向量有1万个元素
c<-seq(from=1,to=10000,by=1)
#我们自创一个xdy函数，利用向量的方法和简单for循环计数其中的奇数元素个数
xdy<-function(x){
j<-c()
for(i in 1:length(x)){
if(x[i]%%2!=0){
j<-c(j,x[i])
i<-i+1}
else{i<i+1}
}
return(length(j))
}
#以上整体思路是定义一个空向量，如果目标向量中某个元素模2不等于0那么就把该元素添加进入空向量中，再加上角标判断下一个元素，如果等于0，只加角标判断下一个元素。最后返回空向量长度。
xdy(c)
[1] 5000
f<-cbind(c(1,2,3),c(4,5,6)) #将两个向量按列捆绑可得得到矩阵
f
      [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
f<-rbind(c(1,2,3),c(4,5,6)) #将两个向量按行捆绑得到的矩阵
f
      [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
 f+10:13
     [,1] [,2] [,3]
[1,]   11   14   13
[2,]   15   18   17
#10:13是利用冒号生成10~13这四个元素组成的向量，这里就是向量运算的循环补齐，在运算的时候，向量按照列的方向加到矩阵上，不足的地方通过循环补齐，如下
1+10 2+12 3+10
4+11 5+13 6+11
#另外我发现，当向量元素个数多于矩阵元素个数时，无法被循环补齐，我后续再说这个问题。向量与向量运算时，短向量循环补齐长向量。
a<-1:7
a*c(1,4,7)
[1]  1  8 21  4 20 42  7
a*1:7
[1]  1  4  9 16 25 36 49 #注意向量和向量的乘法在R中与线性代数不一样。
#刚才在书上看了一个有意思的题目，我看完很快就有思路，可是写的代码有bug,所以debug了好一会儿，毕竟作为一个生物科学出身的人再学编程还是有个过渡，好在靠自己解决了！
#这个题目大概是这样的，找游程（在由0,1组成的序列中，一个由连续0或1构成的串称为游程），书上要找长度为2的1组成的游程。我自己的代码是这样的
dx<-function(x){
j<-c()
for(i in 1:(length(x)-1)){    #这里就是一开始出错的地方，一开始我让i最大取值到length(x),后来发现逻辑不对，后面的代码有i+1，超过了。所以这里只能到i-1
if((x[i+1]-x[i]==0) && (x[i]==1)){  #这里的if中是并列条件，用逻辑运算与连接 &&，同时在编程中我学到了if中的条件都是逻辑条件，应该为逻辑值。  
j<-c(j,i)
i<-i+1}
else{i<-i+1}
}
return(j)
}
y<-c(1,0,0,1,1,1,0,1,1)
dx(y)
[1] 4 5 8

#看完书上的代码我觉得非常妙，因为书上代码可以找任意长度的游程，我针对不同长度还要单独写函数。
findruns<-function(x,k){
n<-length(x)
runs<-NULL
for(i in 1:(n-k+1)){
if(all(x[i:(i+k-1)]==1)) runs<-c(runs,i)
}
return(runs)
}
findruns(y,2)
#书上的代码则用到了all any函数，分别报告其参数是否至少有一个或者全部为TRUE
x<-1:10
any(x>8)
[1] TRUE
any(x>100)
[1] FALSE
all(x>8)
[1] FALSE
all(x>0)
[1] TRUE












