#向量是R语言最基本的数据类型。重点：
#1.循环补齐：在一定情况下自动延长向量；
#2.提取向量子集；
#3.向量化：对向量的每一个元素应用函数。
x<-c(1,2,3,4,5) #把向量赋值给x，c是连接函数。
length(x) #获取向量长度
[1] 5
x[-1:-2] #删除x前两个元素
[1] 3 4 5
x<-x[-1:-2] #删除x前两个元素并保存
x
[1] 3 4 5
x<-c(x[c(1,3)],2,0,1,x[2]) #把x的第一个和第三个元素提取作为新x的第一和第二个元素，并将x的第二的元素提取作为新x的最后一个元素，并在x的第二和最后一个元素之间加入三个新元素，并保存至新x
x
[1] 3 5 2 0 1 4
 b<-seq(from=1,to=100,by=2) #seq函数是生成等差数列函数，并赋给b向量
 b
 [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55
[29] 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 #前面的[1]是计数，代表第一个，57前面的[29]代表57是第29个数
#当向量中元素非常多，而我们又想知道里面奇数有多少个的时候，我们可以利用简单的for循环完成
#例如，我们产生一个向量有1万个元素
c<-seq(from=1,to=10000,by=1)
#我们自创一个xdy函数，利用向量的方法和简单for循环计数其中的奇数元素个数
xdy<-function(x){
j<-c()
for(i in 1:length(x)){
if(x[i]%%2!=0){
j<-c(j,x[i])
i<-i+1}
else{i<i+1}
}
return(length(j))
}
#以上整体思路是定义一个空向量，如果目标向量中某个元素模2不等于0那么就把该元素添加进入空向量中，再加上角标判断下一个元素，如果等于0，只加角标判断下一个元素。最后返回空向量长度。
xdy(c)
[1] 5000
f<-cbind(c(1,2,3),c(4,5,6)) #将两个向量按列捆绑可得得到矩阵
f
      [,1] [,2]
[1,]    1    4
[2,]    2    5
[3,]    3    6
f<-rbind(c(1,2,3),c(4,5,6)) #将两个向量按行捆绑得到的矩阵
f
      [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
 f+10:13
     [,1] [,2] [,3]
[1,]   11   14   13
[2,]   15   18   17
#10:13是利用冒号生成10~13这四个元素组成的向量，这里就是向量运算的循环补齐，在运算的时候，向量按照列的方向加到矩阵上，不足的地方通过循环补齐，如下
1+10 2+12 3+10
4+11 5+13 6+11
#另外我发现，当向量元素个数多于矩阵元素个数时，无法被循环补齐，我后续再说这个问题。向量与向量运算时，短向量循环补齐长向量。
a<-1:7
a*c(1,4,7)
[1]  1  8 21  4 20 42  7
a*1:7
[1]  1  4  9 16 25 36 49 #注意向量和向量的乘法在R中与线性代数不一样。
#刚才在书上看了一个有意思的题目，我看完很快就有思路，可是写的代码有bug,所以debug了好一会儿，毕竟作为一个生物科学出身的人再学编程还是有个过渡，好在靠自己解决了！
#这个题目大概是这样的，找游程（在由0,1组成的序列中，一个由连续0或1构成的串称为游程），书上要找长度为2的1组成的游程。我自己的代码是这样的
dx<-function(x){
j<-c()
for(i in 1:(length(x)-1)){    #这里就是一开始出错的地方，一开始我让i最大取值到length(x),后来发现逻辑不对，后面的代码有i+1，超过了。所以这里只能到i-1
if((x[i+1]-x[i]==0) && (x[i]==1)){  #这里的if中是并列条件，用逻辑运算与连接 &&，同时在编程中我学到了if中的条件都是逻辑条件，应该为逻辑值。  
j<-c(j,i)
i<-i+1}
else{i<-i+1}
}
return(j)
}
y<-c(1,0,0,1,1,1,0,1,1)
dx(y)
[1] 4 5 8

#看完书上的代码我觉得非常妙，因为书上代码可以找任意长度的游程，我针对不同长度还要单独写函数。
findruns<-function(x,k){
n<-length(x)
runs<-NULL
for(i in 1:(n-k+1)){
if(all(x[i:(i+k-1)]==1)) runs<-c(runs,i)
}
return(runs)
}
findruns(y,2)
#书上的代码则用到了all any函数，分别报告其参数是否至少有一个或者全部为TRUE
x<-1:10
any(x>8)
[1] TRUE
any(x>100)
[1] FALSE
all(x>8)
[1] FALSE
all(x>0)
[1] TRUE


#今天遇到一个有意思的问题，关于天气预测的问题，我思考有一个漏洞，虽然最后写出了代码，但是这段代码不能正确解决这个问题。不过这段代码让我更加熟练使用嵌套循环
#大概这么一个简单的神经网络预测时间序列的模型：假设每天的天气数据，1代表下雨，0代表没有雨。假设已经知道最近几天是否下雨，我们希望预测明天是否会下雨，具体而言
对于某个K值，我们会根据最近k天的天气记录来预测明天的天气。我们将使用过半数规则“过半数规则”：如果在最近k期里1的数量大于等于k/2，那么预测下一个值为1，否则预测
下一个值为0，例如如果k=3,最近三期的数据为1、0、1，则预测下一期为1。
#但是，我们应该如何选择K，显然值太小，则给我们预测的样本量太小。值太大，导致我们使用过于早期的数据（成为训练集），变换不同K值，看看预测如何。
#对于这个问题，我很快有思路，如果我每次选择一个K值划分后预测下一期的值，那么对于第k+i天，他们都存在一个预测值和真值，由预测值组成的向量和真值组成的向量差的和
越小。于是我这这么做了，用了嵌套循环写出了代码，但是我忽略了一个问题，就是预测率。当k逐渐增大的时候差的和会出现总体下降的趋势。先写上我思考后的代码。
#我的代码还自写了两个求和函数，当然，第一个函数我傻傻地忘记了R就有的。
sum<-function(x){
  j<-0
  for(i in 1:length(x)){
    j<-j+x[i]
    i<-i+1}
  return(j)
}
suum<-function(x){
  j<-0
  for(i in 1:length(x)){
    j<-j+abs(x[i])
    i<-i+1}
  return(j)
}
xdy2<-function(x){
  for(k in 3:(length(x)-1)){
    for(i in 1:(length(x)-k)){
      n<-c()
      m<-c()
      j<-c(x[i:(i+k-1)])
      if(sum(j)>=k/2){
        m<-c(m,1)
        i<-i+1}
      else{
        m<-c(m,0)
        i<-i+1}
    }
    n<-c(m-x[(k+1):(length(x)-1)])
    print(suum(n))
    print(k)
    k<-k+1
  }
}
y
 [1] 1 0 1 0 1 1 1 0 1 0 1
 xdy2(y)
[1] 4
[1] 3
[1] 2
[1] 4
[1] 2
[1] 5
[1] 2
[1] 6
[1] 2
[1] 7
[1] 1
[1] 8
[1] 1
[1] 9
[1] 1
[1] 10
#以上是我自己写的代码，下面是作者的代码，很精妙
preda<-function(x,k){
n<-length(x)
k2<-k/2
#the vector pred will contain our predicted values
pred<-vector(length=n-k)
for(i in 1:(n-k)){
if(sum(x[i:(i+(k-1))])>=k2) pred[i]<-1 else pred[i]<-0
}
return(mean(abs(pred-x[(k+1):n])))
}

#向量化运算
#原书叫向量化运算符，这里是指，当函数在以向量为自变量的时候做运算，那么函数也被向量化，这样做可以大大提高运算速度
u<-c(5,2,1)
v<-c(6,3,2)
u<v
[1] TRUE TRUE TRUE
w<-function(x){ return(x+1)
}
w(v)
[1] 7 4 3
y<-round(-0.7,0.5) #round是取四舍五入近似值
y
[1] -0.7
#书中提到这样一个例子非常好
f<-function(x,c){
return((x+c)^2)}
f(1:3,1)
[1]  4  9 16
这个函数中c看起来像是一个标量，但是记住，R里面是没有标量的！在这样运算中，c其实是被循环补齐了，c成为了rep(1,3)
f(1:3,1:3) #当我们以向量的形式输入c的时候
[1]  4 16 36
如果，我们想让c强制成为标量
f<-function(x,c){
if(length(c) !=1) stop("vector c not allowed")
return((x+c)^2)
}
f(1:3,1) #输入的c是个标量，但是标量被循环补齐
[1]  4  9 16
f(1:3,1:3)
Error in f(1:3, 1:3) : vector c not allowed
#对于向量的输入，我们可以得到矩阵的输出
sapply函数可以实现，sapply(x,f)对于输入的x使用f函数，并自动将其转化为矩阵输出
z11<-function(x){
return(c(x,x^2,3x))}
sapply(1:8,z11)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
[1,]    1    2    3    4    5    6    7    8
[2,]    1    4    9   16   25   36   49   64
[3,]    3    6    9   12   15   18   21   24
也可是使用matrix函数输出矩阵
matrix(f,ncol= )#输出矩阵有时候不好理解，和线性代数略有不同。
R中有NA值和NULL值。这两个值有不同，NA是缺失值，在计算的时候需要用na.rm=T剔除。NULL是空值，运算无需剔除。因为NA是R中一个存在对象，而NULL在R中是一种特殊对象，没有特殊模式

#今天遇到了这样一个编程问题，和相关性系数有关，虽然现在已经有很多的程序包可以进行相关性分析，但是个人还是写了一个简单的相关性分析的程序
#考虑向量x,y他们是时间序列，定义两者的相关性为同时上升或者下降的的次数占观测次数的总比例。那么我写出以下代码（在这个代码之前我写了一个逻辑有错的代码，运算结果不是正确的，先附上正确代码）
ss<-function(x){  #这个功能函数是在计算向量中两个元素之差，如果上升则记为1，下降记为-1，将1或-1赋值给新向量
  u<-NULL
  b<-length(x)
  for(i in 1:(b-1)){
    ifelse(x[i+1]-x[i]>0,u<-c(u,1),u<-c(u,-1))}
  return(u)
} 
xdy3<-function(x,y){ #这个函数则是是将赋值后的新向量做比较，由于是基于时间序列的向量，那么在同一时间点，二者要么同时上升同时下降（因为定义是这么的，正常的相关性没有这么简单）
  u<-ss(x)
  v<-ss(y)
  w<-c()
  b<-min(length(u),length(v))
  for(i in 1:b){
    ifelse(u[i]==v[i],w<-c(w,1),w<-c(w,0))}
    
  return(mean(w))
}
x
 [1]  5 12 13  3  6  0  1 15 16  8 88
y
 [1]  4  2  3 23  6 10 11 12  6  3  2
 xdy3(x,y) #一定要先运行ss
 [1] 0.4
而我最初写的逻辑有错误的代码是 #等书再学一部分应该回头解决，难道是不能出现两个并列的if？
xdy3<-function(x,y){
  u<-NULL
  v<-NULL
  w<-NULL
  b<-min(length(x),length(y))
  for(i in 1:(b-1)){
    ifelse(x[i+1]-x[i]>0,u<-c(u,1),u<-c(u,-1))
    ifelse(y[j+1]-y[j]>0,v<-c(v,1),u<-c(v,-1))}
  for(i in 1:length(v)){
    ifelse(u[i]==v[i] && u[i]==1,w<-c(w,u[i]),w<-c(w,0))}
  return(mean(w))}

#另外向量还有筛选函数
z<-x[x>3]
z
[1]  5 12 13  6 15 16  8 88
#以上是这样的运算
x>3
[1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE #由此得到布尔值，然后将布尔值带入向量，取结果为TRUE
#使用subset()函数也可做筛选，并且一般筛选会保留NA值，但是subset可以去掉
subset(x,x>6)
[1] 12 13 15 16  8 88
#而which函数可以产生向量的索引，并将索引以向量的形式给出
which(x>4)
[1]  1  2  3  5  8  9 10 11













